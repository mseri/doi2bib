(* BibTeX Parser and Pretty Printer in OCaml *)
(* Edited from the version generated by Claude at
   https://claude.ai/share/6cdc04c1-ca20-4efc-93c2-474438dda8cf *)

(* Types for representing BibTeX entries *)
type field_value = StringValue of string | NumberValue of int
type field = { name : string; value : field_value }

type entry_type =
  | Article
  | Book
  | Booklet
  | Conference
  | InBook
  | InCollection
  | InProceedings
  | Manual
  | MastersThesis
  | Misc
  | PhdThesis
  | Proceedings
  | TechReport
  | Unpublished

type bibtex_entry = {
  entry_type : entry_type;
  citekey : string;
  fields : field list;
}

type bibtex_item = Entry of bibtex_entry | Comment of string

(* Utility functions *)
let string_of_entry_type = function
  | Article -> "article"
  | Book -> "book"
  | Booklet -> "booklet"
  | Conference -> "conference"
  | InBook -> "inbook"
  | InCollection -> "incollection"
  | InProceedings -> "inproceedings"
  | Manual -> "manual"
  | MastersThesis -> "mastersthesis"
  | Misc -> "misc"
  | PhdThesis -> "phdthesis"
  | Proceedings -> "proceedings"
  | TechReport -> "techreport"
  | Unpublished -> "unpublished"

let entry_type_of_string s =
  match String.lowercase_ascii s with
  | "article" -> Article
  | "book" -> Book
  | "booklet" -> Booklet
  | "conference" -> Conference
  | "inbook" -> InBook
  | "incollection" -> InCollection
  | "inproceedings" -> InProceedings
  | "manual" -> Manual
  | "mastersthesis" -> MastersThesis
  | "misc" -> Misc
  | "phdthesis" -> PhdThesis
  | "proceedings" -> Proceedings
  | "techreport" -> TechReport
  | "unpublished" -> Unpublished
  | _ -> Misc (* fallback to misc for unknown types *)

(* Simple Parser Combinator Library *)
type 'a parser = string -> int -> ('a * int) option

let return x _input pos = Some (x, pos)
let fail _input _pos = None

let bind p f input pos =
  match p input pos with Some (x, pos') -> f x input pos' | None -> None

let ( >>= ) = bind

let ( <|> ) p1 p2 input pos =
  match p1 input pos with Some result -> Some result | None -> p2 input pos

let rec many p input pos =
  match p input pos with
  | Some (x, pos') -> (
      match many p input pos' with
      | Some (xs, pos'') -> Some (x :: xs, pos'')
      | None -> Some ([ x ], pos'))
  | None -> Some ([], pos)

let many1 p =
  p >>= fun x ->
  many p >>= fun xs -> return (x :: xs)

let optional p input pos =
  match p input pos with
  | Some (x, pos') -> Some (Some x, pos')
  | None -> Some (None, pos)

(* Character and string parsers *)
let peek_char input pos =
  if pos < String.length input then Some input.[pos] else None

let char c input pos =
  match peek_char input pos with
  | Some c' when c = c' -> Some (c, pos + 1)
  | _ -> None

let satisfy pred input pos =
  match peek_char input pos with
  | Some c when pred c -> Some (c, pos + 1)
  | _ -> None

let rec skip_while pred input pos =
  match peek_char input pos with
  | Some c when pred c -> skip_while pred input (pos + 1)
  | _ -> pos

(* Helper to skip over a comment *)
let skip_comment input pos =
  match peek_char input pos with
  | Some '%' ->
      let rec skip_to_eol pos =
        match peek_char input pos with
        | None -> pos
        | Some '\n' -> pos + 1
        | Some '\r' ->
            if pos + 1 < String.length input && input.[pos + 1] = '\n' then
              pos + 2
            else pos + 1
        | Some _ -> skip_to_eol (pos + 1)
      in
      skip_to_eol (pos + 1)
  | _ -> pos

let whitespace input pos =
  let rec skip_ws_and_comments pos =
    let pos' =
      skip_while
        (function ' ' | '\t' | '\n' | '\r' -> true | _ -> false)
        input pos
    in
    match peek_char input pos' with
    | Some '%' -> skip_ws_and_comments (skip_comment input pos')
    | _ -> pos'
  in
  Some ((), skip_ws_and_comments pos)

let ws p =
  whitespace >>= fun _ ->
  p >>= fun x ->
  whitespace >>= fun _ -> return x

let string s input pos =
  let len = String.length s in
  if pos + len <= String.length input && String.sub input pos len = s then
    Some (s, pos + len)
  else None

let take_while pred input pos =
  let start = pos in
  let pos' = skip_while pred input pos in
  if pos' > start then Some (String.sub input start (pos' - start), pos')
  else None

let take_while1 pred input pos =
  match take_while pred input pos with
  | Some (s, pos') when String.length s > 0 -> Some (s, pos')
  | _ -> None

(* BibTeX specific parsers *)
let is_alpha c = (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')
let is_digit c = c >= '0' && c <= '9'
let is_alnum c = is_alpha c || is_digit c
let is_ident_char c = is_alnum c || c = '_' || c = '-' || c = ':'

(* More permissive field name parser to handle dots, plus signs, etc. *)
let is_field_name_char c =
  is_alnum c || c = '_' || c = '-' || c = ':' || c = '.' || c = '+'

let identifier =
  satisfy (fun c -> is_alpha c || c = '_') >>= fun first ->
  take_while is_ident_char >>= fun rest -> return (String.make 1 first ^ rest)

let field_name =
  satisfy (fun c -> is_alpha c || c = '_') >>= fun first ->
  take_while is_field_name_char >>= fun rest ->
  return (String.make 1 first ^ rest)

let number =
  take_while1 is_digit >>= fun digits -> return (int_of_string digits)

(* Helper to handle multi-byte UTF-8 characters safely *)
let is_utf8_continuation_byte c =
  let code = Char.code c in
  code >= 0x80 && code <= 0xBF

let quoted_string input pos =
  match char '"' input pos with
  | Some (_, pos1) ->
      let rec loop acc pos brace_level =
        match peek_char input pos with
        | None -> None
        | Some '"' when brace_level = 0 -> Some (acc, pos + 1)
        | Some '{' -> loop (acc ^ "{") (pos + 1) (brace_level + 1)
        | Some '}' -> loop (acc ^ "}") (pos + 1) (max 0 (brace_level - 1))
        | Some '\\' when pos + 1 < String.length input ->
            let escaped = String.sub input (pos + 1) 1 in
            loop (acc ^ "\\" ^ escaped) (pos + 2) brace_level
        | Some c ->
            (* Check if this is a UTF-8 multi-byte character *)
            if Char.code c >= 0xC0 then
              (* Leading byte of multi-byte sequence *)
              let rec collect_utf8 bytes_left acc_utf8 curr_pos =
                if bytes_left = 0 then (acc_utf8, curr_pos)
                else
                  match peek_char input curr_pos with
                  | Some c when is_utf8_continuation_byte c ->
                      collect_utf8 (bytes_left - 1)
                        (acc_utf8 ^ String.make 1 c)
                        (curr_pos + 1)
                  | _ -> (acc_utf8, curr_pos)
              in
              let bytes_to_read =
                if Char.code c >= 0xC0 && Char.code c <= 0xDF then 1
                else if Char.code c >= 0xE0 && Char.code c <= 0xEF then 2
                else if Char.code c >= 0xF0 && Char.code c <= 0xF7 then 3
                else 0
              in
              let utf8_seq, new_pos =
                collect_utf8 bytes_to_read (String.make 1 c) (pos + 1)
              in
              loop (acc ^ utf8_seq) new_pos brace_level
            else
              (* ASCII or continuation byte (shouldn't happen here) *)
              loop (acc ^ String.make 1 c) (pos + 1) brace_level
      in
      loop "" pos1 0
  | None -> None

let braced_string input pos =
  match char '{' input pos with
  | Some (_, pos1) ->
      let rec loop acc pos brace_level =
        match peek_char input pos with
        | None -> None
        | Some '}' when brace_level = 1 -> Some (acc, pos + 1)
        | Some '{' -> loop (acc ^ "{") (pos + 1) (brace_level + 1)
        | Some '}' -> loop (acc ^ "}") (pos + 1) (brace_level - 1)
        | Some '\\' when pos + 1 < String.length input ->
            let escaped = String.sub input (pos + 1) 1 in
            loop (acc ^ "\\" ^ escaped) (pos + 2) brace_level
        | Some c ->
            (* Check if this is a UTF-8 multi-byte character *)
            if Char.code c >= 0xC0 then
              (* Leading byte of multi-byte sequence *)
              let rec collect_utf8 bytes_left acc_utf8 curr_pos =
                if bytes_left = 0 then (acc_utf8, curr_pos)
                else
                  match peek_char input curr_pos with
                  | Some c when is_utf8_continuation_byte c ->
                      collect_utf8 (bytes_left - 1)
                        (acc_utf8 ^ String.make 1 c)
                        (curr_pos + 1)
                  | _ -> (acc_utf8, curr_pos)
              in
              let bytes_to_read =
                if Char.code c >= 0xC0 && Char.code c <= 0xDF then 1
                else if Char.code c >= 0xE0 && Char.code c <= 0xEF then 2
                else if Char.code c >= 0xF0 && Char.code c <= 0xF7 then 3
                else 0
              in
              let utf8_seq, new_pos =
                collect_utf8 bytes_to_read (String.make 1 c) (pos + 1)
              in
              loop (acc ^ utf8_seq) new_pos brace_level
            else
              (* ASCII or continuation byte (shouldn't happen here) *)
              loop (acc ^ String.make 1 c) (pos + 1) brace_level
      in
      loop "" pos1 1
  | None -> None

(* Parser for unquoted values like month=jul *)
let is_unquoted_value_char c =
  is_alnum c || c = '_' || c = '-' || c = '.' || c = '/' || c = ':' || c = '+'
  || c = '~' || c = '@' || c = '#' || c = '$' || c = '%' || c = '^' || c = '&'
  || c = '*' || c = '(' || c = ')' || c = '[' || c = ']'

let unquoted_value = take_while1 is_unquoted_value_char

(* Enhanced field_value parser that can handle unquoted values like month=jul *)
let field_value =
  quoted_string
  >>= (fun s -> return (StringValue s))
  <|> (braced_string >>= fun s -> return (StringValue s))
  <|> (number >>= fun n -> return (NumberValue n))
  <|> (unquoted_value >>= fun s -> return (StringValue s))

let field_entry =
  ws field_name >>= fun name ->
  ws (char '=') >>= fun _ ->
  ws field_value >>= fun value -> return { name; value }

let field_list =
  optional
    ( field_entry >>= fun first ->
      many (ws (char ',') >>= fun _ -> ws field_entry) >>= fun rest ->
      (* Handle optional trailing commas (any number) *)
      let rec skip_trailing_commas input pos =
        match ws (char ',') input pos with
        | Some (_, pos') -> skip_trailing_commas input pos'
        | None -> Some ((), pos)
      in
      bind skip_trailing_commas (fun _ -> return (first :: rest)) )
  >>= fun fields -> return (match fields with Some fs -> fs | None -> [])

let entry_type_parser =
  identifier >>= fun type_str -> return (entry_type_of_string type_str)

let bibtex_entry =
  ws (char '@') >>= fun _ ->
  entry_type_parser >>= fun entry_type ->
  ws (char '{') >>= fun _ ->
  ws identifier >>= fun citekey ->
  optional (ws (char ',') >>= fun _ -> field_list) >>= fun fields ->
  ws (char '}') >>= fun _ ->
  return
    {
      entry_type;
      citekey;
      fields = (match fields with Some fs -> fs | None -> []);
    }

let comment =
  char '%' >>= fun _ ->
  take_while (fun c -> c <> '\n' && c <> '\r') >>= fun text -> return text

let bibtex_item =
  bibtex_entry
  >>= (fun entry -> return (Entry entry))
  <|> (comment >>= fun text -> return (Comment text))

let bibtex_file =
  many (ws bibtex_item) >>= fun items ->
  ws (return ()) >>= fun _ -> return items

(* Parser runner *)
let parse_with parser input =
  match parser input 0 with Some (result, _) -> Some result | None -> None

let parse_bibtex input =
  match parse_with bibtex_file input with Some items -> items | None -> []

(* String replacement helper for Unicode normalization *)
let replace_string ~pattern ~replacement text =
  let pattern_len = String.length pattern in
  if pattern_len = 0 then text
  else
    let rec find_and_replace start_pos acc =
      try
        let match_pos = String.index_from text start_pos pattern.[0] in
        if
          match_pos + pattern_len <= String.length text
          && String.sub text match_pos pattern_len = pattern
        then
          (* Found a match - add up to match, add replacement, continue *)
          let prefix = String.sub text start_pos (match_pos - start_pos) in
          find_and_replace (match_pos + pattern_len) (acc ^ prefix ^ replacement)
        else
          (* False positive - add the character and continue *)
          let next_pos = match_pos + 1 in
          let prefix = String.sub text start_pos (next_pos - start_pos) in
          find_and_replace next_pos (acc ^ prefix)
      with Not_found ->
        (* No more matches - add the rest of the string *)
        if start_pos < String.length text then
          acc ^ String.sub text start_pos (String.length text - start_pos)
        else acc
    in
    find_and_replace 0 ""

(* Normalize Unicode to ASCII equivalents where possible *)
let normalize_unicode s =
  (* This is a simplified version that just handles a few common cases *)
  let replacements =
    [
      ("\226\128\147", "-");
      (* en-dash *)
      ("\226\128\148", "--");
      (* em-dash *)
      ("\226\128\156", "\"");
      (* left double quote *)
      ("\226\128\157", "\"");
      (* right double quote *)
      ("\226\128\152", "'");
      (* left single quote *)
      ("\226\128\153", "'");
      (* right single quote *)
    ]
  in
  let s_ref = ref s in
  List.iter
    (fun (from, to_) ->
      s_ref := replace_string ~pattern:from ~replacement:to_ !s_ref)
    replacements;
  !s_ref

(* Pretty printer *)
let format_field_value = function
  | StringValue s ->
      (* Use braces if the string contains quotes, otherwise use quotes *)
      let normalized_s = normalize_unicode s in
      if String.contains normalized_s '"' then "{" ^ normalized_s ^ "}"
      else "\"" ^ normalized_s ^ "\""
  | NumberValue n -> string_of_int n

let format_field field =
  "  " ^ field.name ^ " = " ^ format_field_value field.value

let format_entry entry =
  let entry_type_str = string_of_entry_type entry.entry_type in
  let header = "@" ^ entry_type_str ^ "{" ^ entry.citekey in
  let fields_str =
    if entry.fields = [] then ""
    else ",\n" ^ String.concat ",\n" (List.map format_field entry.fields)
  in
  header ^ fields_str ^ "\n}"

let format_bibtex_item = function
  | Entry entry -> format_entry entry
  | Comment comment -> "%" ^ comment

let pretty_print_bibtex items =
  String.concat "\n\n" (List.map format_bibtex_item items)

(* Helper function to clean and normalize BibTeX entries *)
let clean_bibtex input =
  let parsed_items = parse_bibtex input in
  pretty_print_bibtex parsed_items
